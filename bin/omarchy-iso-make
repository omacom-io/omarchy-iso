#!/bin/bash

# Abort if anything fails
set -e

# Parse command line arguments
NO_CACHE=""
while [[ $# -gt 0 ]]; do
  case $1 in
  --no-cache)
    NO_CACHE=1
    shift
    ;;
  --no-boot-offer)
    NO_BOOT_OFFER=1
    shift
    ;;
  --local-source)
    LOCAL_SOURCE=1
    shift
    ;;
  --dev)
    OMARCHY_INSTALLER_REF=dev
    shift
    ;;
  --edge)
    OMARCHY_MIRROR=edge
    shift
    ;;
  --rc)
    OMARCHY_MIRROR=rc
    shift
    ;;
  *)
    echo "Unknown option: $1"
    echo "Usage: $0 [--no-cache] [--no-boot-offer] [--local-source] [--dev] [--edge] [--rc]"
    exit 1
    ;;
  esac
done

# Ensure we have the submodule checked out
git submodule update --init --recursive --jobs=8

# Prepare build repo
BUILD_SCRIPT="builder/build-iso.sh"
BUILD_ROOT=$(realpath "${BASH_SOURCE[0]%/*}/..")
BUILD_RELEASE_PATH="$BUILD_ROOT/release"
mkdir -p "$BUILD_RELEASE_PATH"

OMARCHY_INSTALLER_REPO="${OMARCHY_INSTALLER_REPO:-basecamp/omarchy}"
OMARCHY_INSTALLER_REF="${OMARCHY_INSTALLER_REF:-master}"
OMARCHY_MIRROR="${OMARCHY_MIRROR:-stable}"

DOCKER_ARGS=(
  --privileged
  -e "OMARCHY_INSTALLER_REPO=$OMARCHY_INSTALLER_REPO"
  -e "OMARCHY_INSTALLER_REF=$OMARCHY_INSTALLER_REF"
  -e "OMARCHY_MIRROR=$OMARCHY_MIRROR"
  -e "HOST_UID=$(id -u)"
  -e "HOST_GID=$(id -g)"
  -v "$BUILD_RELEASE_PATH/:/out/"
  -v "$BUILD_ROOT/$BUILD_SCRIPT:/$BUILD_SCRIPT:ro"
  -v "$BUILD_ROOT/archiso:/archiso:ro"
  -v "$BUILD_ROOT/builder:/builder:ro"
  -v "$BUILD_ROOT/configs:/configs:ro"
)

# Use local source of Omarchy from $OMARCHY_PATH instead of git checkout
if [[ -n "${LOCAL_SOURCE-}" ]]; then
  DOCKER_ARGS+=(-v "$OMARCHY_PATH:/omarchy:ro")
fi

# Use local pacman cache if you already have one on host to speed up repeat runs
if [ -d "/var/cache/pacman/pkg" ]; then
  DOCKER_ARGS+=(-v "/var/cache/pacman/pkg:/var/cache/pacman/pkg")
fi

# Mount the build cache directory where packages are downloaded
if [[ -z "$NO_CACHE" ]]; then
  # Using a 24-hour window cache (not daily) to handle rapid Arch package updates
  # Cache is valid for 24 hours from first build, then refreshes
  # Format: YYYYMMDD_HH (e.g., 20260111_14 for Jan 11, 2026 at 14:00)
  BUILD_TIMESTAMP=$(date +%Y%m%d_%H)
  OFFLINE_REPO_BUILD_CACHE_DIR="$HOME/.cache/omarchy/iso_${BUILD_TIMESTAMP}/airootfs/var/cache/omarchy"
  mkdir -p "$OFFLINE_REPO_BUILD_CACHE_DIR"
  # Mount to /var/cache/airootfs/var/cache/omarchy since that's where repo packages go in the ISO
  DOCKER_ARGS+=(-v "$OFFLINE_REPO_BUILD_CACHE_DIR:/var/cache/airootfs/var/cache/omarchy")
fi

# Clean up any existing omarchy-iso build containers (but not other containers)
# Use a specific container name to avoid touching other containers
OMARCHY_BUILD_CONTAINER_NAME="omarchy-iso-build-$(id -u)"
if docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "^${OMARCHY_BUILD_CONTAINER_NAME}$"; then
  echo "Cleaning up previous omarchy-iso build container: ${OMARCHY_BUILD_CONTAINER_NAME}"
  docker rm -f "${OMARCHY_BUILD_CONTAINER_NAME}" 2>/dev/null || true
fi

# Run the builder with assembled args
# Use --name to create a named container for easy cleanup
# Note: --rm is removed from DOCKER_ARGS since we're using a named container
DOCKER_ARGS_NO_RM=()
for arg in "${DOCKER_ARGS[@]}"; do
  [[ "$arg" != "--rm" ]] && DOCKER_ARGS_NO_RM+=("$arg")
done

docker run --name "${OMARCHY_BUILD_CONTAINER_NAME}" "${DOCKER_ARGS_NO_RM[@]}" archlinux/archlinux:latest /$BUILD_SCRIPT

# Clean up the container after build completes
docker rm "${OMARCHY_BUILD_CONTAINER_NAME}" 2>/dev/null || true

# Move as install ref
latest_iso=$(\ls -t "$BUILD_RELEASE_PATH"/*.iso | head -n1)
iso_ref="${latest_iso%.*}-$OMARCHY_INSTALLER_REF.iso"
mv -f "$latest_iso" "$iso_ref"

# Offer to boot the new build
if [[ -z "$NO_BOOT_OFFER" ]]; then
  echo
  gum confirm "Boot $iso_ref?" && omarchy-iso-boot "$iso_ref"
fi
